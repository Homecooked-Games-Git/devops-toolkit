# Shared Fastfile for Homecooked Games Unity builds
#
# Imported by game repos via:
#   import_from_git(url: "https://github.com/Homecooked-Games-Git/devops-toolkit.git",
#                   branch: "main", path: "fastlane/Fastfile")
#
# app_identifier is read automatically from ProjectSettings/ProjectSettings.asset
#
# The reusable workflow sets:
#   FL_GAME_NAME           - used for IPA filename
#   FL_XCODE_PROJECT_DIR   - path to Unity's Xcode export (default: "build/iOS/iOS")

require "json"

default_platform(:ios)

TEAM_ID = "X3DPX6VLNN"

# Read bundle identifier from Unity ProjectSettings.
# GITHUB_WORKSPACE anchors the path when imported via import_from_git
# (which runs from a temp clone directory).
def resolve_app_identifier(platform_key = "iPhone")
  root = ENV["GITHUB_WORKSPACE"] || Dir.pwd
  path = File.join(root, "ProjectSettings", "ProjectSettings.asset")
  settings = File.read(path)
  m = settings.match(/applicationIdentifier:.*?#{platform_key}:\s*([\w.\-]+)/m)
  UI.user_error!("No #{platform_key} app identifier found in #{path}") unless m
  m[1].strip
end

def resolve_firebase_app_id(platform)
  root = ENV["GITHUB_WORKSPACE"] || Dir.pwd
  if platform == :android
    path = File.join(root, "Assets", "Settings", "google-services.json")
    json = JSON.parse(File.read(path))
    json["client"][0]["client_info"]["mobilesdk_app_id"]
  else
    path = File.join(root, "Assets", "Settings", "GoogleService-Info.plist")
    content = File.read(path)
    m = content.match(/<key>GOOGLE_APP_ID<\/key>\s*<string>([^<]+)<\/string>/)
    UI.user_error!("No GOOGLE_APP_ID found in #{path}") unless m
    m[1]
  end
end

def write_firebase_release_url
  release = lane_context[SharedValues::FIREBASE_APP_DISTRO_RELEASE]
  return unless release
  root = ENV["GITHUB_WORKSPACE"] || Dir.pwd
  url = release[:testingUri] || release["testingUri"] || ""
  File.write(File.join(root, "firebase_release_url.txt"), url)
  UI.success("Firebase testing URL: #{url}") unless url.empty?
end

def find_android_artifact
  root = ENV["GITHUB_WORKSPACE"] || Dir.pwd
  build_dir = File.join(root, "build", "Android")
  aab = Dir.glob(File.join(build_dir, "**", "*.aab")).first
  apk = Dir.glob(File.join(build_dir, "**", "*.apk")).first
  aab || apk || UI.user_error!("No AAB or APK found in #{build_dir}")
end

# ── iOS ──

platform :ios do

  private_lane :setup_api_key do
    app_store_connect_api_key(
      key_id: ENV.fetch("APP_STORE_CONNECT_API_KEY_KEY_ID"),
      issuer_id: ENV.fetch("APP_STORE_CONNECT_API_KEY_ISSUER_ID"),
      key_content: ENV.fetch("APP_STORE_CONNECT_API_KEY_KEY"),
      in_house: false
    )
  end

  private_lane :setup_keychain do
    keychain_password = ENV["MATCH_KEYCHAIN_PASSWORD"] || ""

    create_keychain(
      name: "fastlane_keychain",
      password: keychain_password,
      default_keychain: true,
      unlock: true,
      timeout: 3600
    )

    keychain_password
  end

  desc "Build iOS IPA from Unity Xcode export"
  lane :build do |options|
    sign_type = options[:sign_type] || "appstore"
    root        = ENV["GITHUB_WORKSPACE"] || Dir.pwd
    app_id      = resolve_app_identifier
    xcode_dir   = File.join(root, ENV["FL_XCODE_PROJECT_DIR"] || "build/iOS/iOS")
    game_name   = ENV.fetch("FL_GAME_NAME")

    if File.exist?("#{xcode_dir}/Podfile")
      cocoapods(
        podfile: "#{xcode_dir}/Podfile",
        try_repo_update_on_error: true
      )
    end

    api_key = setup_api_key
    keychain_password = setup_keychain

    # Ensure the App ID (bundle identifier) is registered in the Developer Portal
    existing = Spaceship::ConnectAPI::BundleId.find(app_id)
    if existing
      UI.message("App ID '#{app_id}' already registered")
    else
      UI.important("App ID '#{app_id}' not found, creating...")
      Spaceship::ConnectAPI::BundleId.create(
        name: game_name,
        identifier: app_id,
        platform: Spaceship::ConnectAPI::BundleIdPlatform::IOS
      )
      UI.success("Created App ID '#{app_id}'")
    end

    match(
      type: sign_type,
      app_identifier: app_id,
      api_key: api_key,
      readonly: sign_type == "appstore",
      force_for_new_devices: sign_type == "adhoc",
      keychain_name: "fastlane_keychain",
      keychain_password: keychain_password
    )

    if sign_type == "appstore"
      profile_name = "match AppStore #{app_id}"
      export_method = "app-store"
    else
      profile_name = "match AdHoc #{app_id}"
      export_method = "ad-hoc"
    end

    update_code_signing_settings(
      use_automatic_signing: false,
      path: "#{xcode_dir}/Unity-iPhone.xcodeproj",
      team_id: TEAM_ID,
      bundle_identifier: app_id,
      profile_name: profile_name,
      code_sign_identity: "Apple Distribution",
      targets: ["Unity-iPhone"]
    )

    workspace_path = "#{xcode_dir}/Unity-iPhone.xcworkspace"
    project_path   = "#{xcode_dir}/Unity-iPhone.xcodeproj"

    build_opts = {
      scheme: "Unity-iPhone",
      export_method: export_method,
      output_directory: "#{xcode_dir}/output",
      output_name: "#{game_name}.ipa",
      clean: true,
      export_options: {
        signingStyle: "manual",
        provisioningProfiles: {
          app_id => profile_name
        }
      }
    }

    if File.exist?(workspace_path)
      build_opts[:workspace] = workspace_path
    else
      build_opts[:project] = project_path
    end

    build_app(build_opts)
  end

  desc "Build and upload to TestFlight"
  lane :beta do
    build(sign_type: "appstore")

    api_key = setup_api_key

    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true
    )
  end

  desc "Build and upload to Firebase App Distribution"
  lane :firebase do
    root = ENV["GITHUB_WORKSPACE"] || Dir.pwd
    app_id = resolve_app_identifier
    firebase_app_id = resolve_firebase_app_id(:ios)
    udid_file = File.join(root, "firebase_udids.csv")

    # Fetch tester UDIDs from Firebase and register with Apple
    firebase_app_distribution_get_udids(
      app: firebase_app_id,
      service_credentials_json_data: ENV.fetch("FIREBASE_SERVICE_ACCOUNT_JSON"),
      output_file: udid_file
    )

    api_key = setup_api_key

    if File.exist?(udid_file)
      register_devices(
        devices_file: udid_file,
        api_key: api_key
      )
    else
      UI.important("No tester UDIDs found — skipping device registration")
    end

    # Build with ad-hoc signing (auto-regenerates profile for new devices)
    build(sign_type: "adhoc")

    firebase_app_distribution(
      app: firebase_app_id,
      service_credentials_json_data: ENV.fetch("FIREBASE_SERVICE_ACCOUNT_JSON"),
      ipa_path: lane_context[SharedValues::IPA_OUTPUT_PATH]
    )

    write_firebase_release_url
  end

end

# ── Android ──

platform :android do

  desc "Upload to Firebase App Distribution"
  lane :firebase do
    firebase_app_distribution(
      app: resolve_firebase_app_id(:android),
      service_credentials_json_data: ENV.fetch("FIREBASE_SERVICE_ACCOUNT_JSON"),
      android_artifact_path: find_android_artifact
    )

    write_firebase_release_url
  end

end
